let provider;
let signer, userAddress;
const selectedNFTs = new Set();
let sortBtn = document.getElementById("sortBtn");
let selectedNft = document.getElementById("selected");

let toggle_SelectAll = document.getElementById("toggleSelectAll");
let currency = {};
async function getNativeTokenInfo() {
  const provider = new ethers.providers.Web3Provider(window.ethereum);
  const network = await provider.getNetwork();
  const chainId = network.chainId;

  const res = await fetch("https://chainlist.org/rpcs.json");
  const chains = await res.json();

  const currentChain = chains.find((c) => c.chainId === chainId);

  if (!currentChain) {
    alert(`‚ö†Ô∏è Network info not found for Chain ID: ${chainId}`);
    return null;
  }

  const token = currentChain.nativeCurrency;
  const symbol = token.symbol.toLowerCase();

  const coingeckoIds = {
    eth: "ethereum",
    matic: "polygon",
    bnb: "binancecoin",
    avax: "avalanche-2",
    ftm: "fantom",
    op: "optimism",
    arb: "arbitrum",
    cro: "crypto-com-chain",
    ada: "cardano",
    etc: "ethereum-classic",
  };

  const cgId = coingeckoIds[symbol];

  let usdPrice = null;

  if (cgId) {
    try {
      const priceRes = await fetch(
        `https://api.coingecko.com/api/v3/simple/price?ids=${cgId}&vs_currencies=usd`
      );
      const priceData = await priceRes.json();
      usdPrice = priceData[cgId]?.usd ?? null;
    } catch (err) {
      console.warn("Unable to fetch USD price from CoinGecko", err);
    }
  } else {
    console.warn("‚ö†Ô∏è Symbol not found in CoinGecko mapping list:", symbol);
  }

  currency = {
    chainId,
    chainName: currentChain.name,
    symbol: token.symbol,
    name: token.name,
    decimals: token.decimals,
    usdPrice,
  };
  return currency;
}
const NFT_CONTRACTS_ = [
  {
    name: "LOK Resource",
    address: "0x241B47bDE91B7d1843cA34Fc694D4e6926f3B83e",
    abi: [
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved)",
    ],
  },
  {
    name: "LOK Drago",
    address: "0xEec2Bc1aFc053E6e93c7811B5511AD9e28994e66",
    abi: [
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved)",
    ],
  },
  {
    name: "LOK Skin",
    address: "0x24E56FfF91E5aCC65B5fD2f194b0bC81509BEAa7",
    abi: [
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved)",
    ],
  },
];
let NFT_CONTRACT;
const dropdown = document.getElementById("dropdown");
(function addoption() {
  let k = 0;
  for (let nft of NFT_CONTRACTS_) {
    const newOption = document.createElement("option");
    newOption.value = k;
    newOption.text = nft.name;
    dropdown.appendChild(newOption);
    k++;
  }
})();
dropdown.addEventListener("change", () => {
  const index = dropdown.value; // L·∫•y value c·ªßa option
  if (index >= 0) {
    NFT_CONTRACT = NFT_CONTRACTS_[index];
    loadNFTs(NFT_CONTRACTS_[index]);
  }
});
const BATCH_CONTRACT_ADDRESS = "0x4B53B37BEb1D08983694F67BaC1C195D0D33dbC7";
const BATCH_ABI = [
  "function batchTransfer(tuple(address nftAddress, address to, uint256 tokenId, uint256 amount, uint8 tokenType)[] items) external",
];

async function connectWallet(auto = false) {
  try {
    const accounts = await provider.send("eth_requestAccounts", []);
    signer = provider.getSigner();
    userAddress = accounts[0];
    document.getElementById("walletAddress").innerText =
      "Your wallet: " + userAddress;
    document.getElementById("connectBtn").classList.add("hidden");
    await getNativeTokenInfo();
    dropdown.classList.remove("hidden");
  } catch (err) {
    if (!auto) {
      alert("‚ùå Failed to connect wallet or was rejected.");
    }
  }
}

document.getElementById("connectBtn").onclick = async () => {
  await connectWallet(false);
};

window.addEventListener("load", async () => {
  provider = new ethers.providers.Web3Provider(window.ethereum);
  try {
    const accounts = await provider.send("eth_accounts", []);
    if (accounts.length > 0) {
      await connectWallet(true);
    }
  } catch (e) {
    console.warn("Auto-connect failed:", e);
  }
});

let cardList = [];
async function loadNFTs(nft, forAddress = userAddress) {
  let traitDropdowns = document.getElementById("traitDropdowns");
  traitDropdowns.innerHTML = "";
  if (!traitDropdowns.classList.contains("hidden"))
    traitDropdowns.classList.add("hidden");
  if (!userAddress) return;
  if (!dropdown.classList.contains("hidden")) {
    dropdown.classList.add("hidden");
  }

  selectedNFTs.clear();
  selectedNft.textContent = "Selected: " + selectedNFTs.size;
  sortBtn.classList.add("hidden");
  toggle_SelectAll.classList.add("hidden");
  const container = document.getElementById("nftList");
  container.innerHTML = "";

  const loading = document.createElement("div");
  loading.id = "loadingIndicator";
  loading.className = "col-span-full text-center text-gray-500 mt-4";
  loading.innerText = "Loading...";
  container.appendChild(loading);

  const contract = new ethers.Contract(nft.address, nft.abi, provider);
  let balance = 0;
  try {
    balance = await contract.balanceOf(forAddress);
  } catch (err) {
    console.warn("Error reading balanceOf:", nft.address, err);
    const errorCard = document.createElement("div");
    errorCard.className = "text-center text-red-600 col-span-full";
    errorCard.innerText = `‚ùå Failed to load NFTs from contract ${nft.address}`;
    container.appendChild(errorCard);
  }

  const BATCH_SIZE = 7;

  for (let offset = 0; offset < balance; offset += BATCH_SIZE) {
    const batchPromises = [];
    for (let i = offset; i < Math.min(offset + BATCH_SIZE, balance); i++) {
      batchPromises.push(
        (async () => {
          try {
            const tokenId = await contract.tokenOfOwnerByIndex(forAddress, i);
            let uri = "",
              metadata = {};
            try {
              uri = await contract.tokenURI(tokenId);
              const res = await fetch(uri);
              metadata = await res.json();
            } catch (err) {
              metadata.name = "Failed to load metadata";
              metadata.image = "";
            }
            return { tokenId, uri, metadata, contract: nft.address };
          } catch (err) {
            return {
              error: true,
              message: "Failed to read token or metadata",
              tokenId: null,
            };
          }
        })()
      );
    }

    const results = await Promise.all(batchPromises);
    for (const data of results) {
      cardList.push(data);
      const card = document.createElement("div");
      card.className =
        "flex flex-col items-center justify-center text-center bg-white rounded-lg shadow-md p-2 transition";

      if (data.error) {
        card.innerHTML = `
            <div class="w-[96px] h-[96px] flex items-center justify-center bg-gray-100 text-red-500 rounded mb-2 text-sm">
              Error
            </div>
            <div class="text-sm font-semibold text-red-600">
              Failed to load NFT
            </div>
            <div class="text-xs text-gray-400">(Invalid Token)</div>
          `;
      } else {
        const { tokenId, uri, metadata } = data;
        card.dataset.contract = nft.address;
        card.dataset.tokenId = tokenId;
        card.dataset.uri = uri;
        card.dataset.metadata = JSON.stringify(metadata);

        card.onclick = (e) => {
          if (e.target.classList.contains("nft-name")) {
            const data = JSON.parse(card.dataset.metadata);
            document.getElementById("metadataModal").classList.remove("hidden");
            document.getElementById("metadataContent").innerText =
              JSON.stringify(data, null, 2);
          } else {
            const key = nft.address + ":" + tokenId;
            if (selectedNFTs.has(key)) {
              selectedNFTs.delete(key);
              card.classList.remove("ring-4", "ring-blue-500", "bg-blue-50");
            } else {
              selectedNFTs.add(key);
              card.classList.add("ring-4", "ring-blue-500", "bg-blue-50");
            }
            selectedNft.textContent = "Selected: " + selectedNFTs.size;
          }
        };

        card.innerHTML = `
            <img src="${metadata.image || ""}" alt="NFT Image"
              class="w-[96px] h-[96px] object-contain rounded mb-2 bg-white" />
            <div class="text-xs lg:text-sm font-semibold nft-name text-blue-700 hover:underline whitespace-nowrap">
              ${metadata.name || "NFT"}
            </div>
            <div class="text-xs text-gray-500 whitespace-nowrap">(ID: ${tokenId})</div>
          `;
      }

      container.appendChild(card);
    }

    await new Promise((res) => setTimeout(res, 200));
  }

  const loadingEl = document.getElementById("loadingIndicator");
  sortBtn.classList.remove("hidden");
  toggle_SelectAll.classList.remove("hidden");
  dropdown.classList.remove("hidden");
  if (loadingEl) loadingEl.remove();
}
function selectNFTsByAttribute(traitType, value, quantity = Infinity) {
  const container = document.getElementById("nftList");
  const cards = container.querySelectorAll("div[data-metadata]");
  let selectedCount = 0;

  for (const card of cards) {
    if (selectedCount >= quantity) break;

    const metadata = JSON.parse(card.dataset.metadata);
    const attributes = metadata.attributes || [];

    const match = attributes.some(
      (attr) => attr.trait_type === traitType && attr.value === value
    );

    if (match) {
      const contract = card.dataset.contract;
      const tokenId = card.dataset.tokenId;
      const key = contract + ":" + tokenId;

      if (!selectedNFTs.has(key)) {
        selectedNFTs.add(key);
        card.classList.add("ring-4", "ring-blue-500", "bg-blue-50");
        selectedCount++;
      }
    }
  }

  selectedNft.textContent = "Selected: " + selectedNFTs.size;
}

// selectNFTsByAttributes(
//   [
//     { trait_type: "Rarity", value: "Epic" },
//     { trait_type: "Type", value: "Dragon" },
//   ],
//   5
// );
function extractTraitsFromFirstNFTs() {
  const container = document.getElementById("nftList");
  const cards = container.querySelectorAll("div[data-metadata]");
  const traitsMap = new Map();

  for (let i = 0; i < cards.length; i++) {
    const metadata = JSON.parse(cards[i].dataset.metadata);
    const attributes = metadata.attributes || [];

    for (const attr of attributes) {
      if (!traitsMap.has(attr.trait_type)) {
        traitsMap.set(attr.trait_type, new Set());
      }
      traitsMap.get(attr.trait_type).add(attr.value);
    }
  }

  return traitsMap;
} //l·∫•y thu·ªôc t√≠nh

function selectNFTsMatchingAllTraits(traitConditions, quantity) {
  let count = 0;
  const traitKey = Object.entries(traitConditions)
    .map(([t, v]) => `${t}:${v}`)
    .join("|");

  for (const card of document.querySelectorAll("#nftList > div")) {
    if (count >= quantity) break;

    const key = card.dataset.contract + ":" + card.dataset.tokenId;
    if (selectedNFTs.has(key)) continue;

    const metadata = JSON.parse(card.dataset.metadata || "{}");
    const attrs = metadata.attributes || [];

    const hasAll = Object.entries(traitConditions).every(([trait, value]) => {
      return attrs.some(
        (attr) => attr.trait_type === trait && attr.value === value
      );
    });

    if (hasAll) {
      selectedNFTs.add(key);
      card.classList.add("ring-4", "ring-blue-500", "bg-blue-50");
      count++;
    }
  }

  selectedNft.textContent = "Selected: " + selectedNFTs.size;

  // Update or append result <p>
  const display = document.getElementById("selectedDisplay");
  let existingP = display.querySelector(`p[data-key="${traitKey}"]`);

  if (existingP) {
    const prev = parseInt(existingP.dataset.count || "0");
    existingP.dataset.count = prev + count;
    existingP.textContent =
      Object.values(traitConditions).join(" - ") + ` - ${prev + count}pcs`;
  } else {
    const p = document.createElement("p");
    p.dataset.key = traitKey;
    p.dataset.count = count;
    p.textContent =
      Object.values(traitConditions).join(" - ") + ` - ${count}pcs`;
    p.className = "text-sm text-gray-700 bg-gray-100 px-2 py-1 rounded";
    display.appendChild(p);
  }
}

function renderTraitTable() {
  const traitsMap = extractTraitsFromFirstNFTs(); // Map<trait_type, Set<value>>
  const container = document.getElementById("traitDropdowns");
  container.innerHTML = "";

  const form = document.createElement("div");
  form.className = "grid grid-cols-4 md:grid-cols-8 xl:grid-cols-10 gap-4";

  const selectedTraits = {};

  for (const [trait, values] of traitsMap) {
    const group = document.createElement("div");

    const label = document.createElement("label");
    label.textContent = trait;
    label.className = "block mb-1 font-semibold";

    const select = document.createElement("select");
    select.className = "w-full border px-2 py-1 rounded";
    select.dataset.trait = trait;
    select.innerHTML = `<option value="">-- Select ${trait} --</option>`;
    for (const val of values) {
      const opt = document.createElement("option");
      opt.value = val;
      opt.textContent = val;
      select.appendChild(opt);
    }

    select.onchange = () => {
      if (select.value) {
        selectedTraits[trait] = select.value;
      } else {
        delete selectedTraits[trait];
      }
    };

    group.appendChild(label);
    group.appendChild(select);
    form.appendChild(group);
  }

  container.appendChild(form);

  // Quantity input
  const quantityContainer = document.createElement("div");
  quantityContainer.className = "mt-4 flex items-center gap-2";

  const quantityLabel = document.createElement("span");
  quantityLabel.textContent = "Quantity to select:";

  const quantityInput = document.createElement("input");
  quantityInput.type = "number";
  quantityInput.min = "1";
  quantityInput.value = "1";
  quantityInput.className = "border px-2 py-1 w-24 rounded";

  quantityContainer.appendChild(quantityLabel);
  quantityContainer.appendChild(quantityInput);
  container.appendChild(quantityContainer);

  // Display selected trait info as <p> tags
  const displayArea = document.createElement("div");
  displayArea.id = "selectedDisplay";
  displayArea.className = "mt-4 space-y-2";
  container.appendChild(displayArea);

  // Select button
  const btnSelect = document.createElement("button");
  btnSelect.textContent = "Select NFTs";
  btnSelect.className = "mt-4 px-4 py-2 bg-blue-600 text-white rounded mr-2";
  btnSelect.onclick = () => {
    const quantity = parseInt(quantityInput.value);
    if (isNaN(quantity) || quantity <= 0) {
      alert("Invalid quantity.");
      return;
    }

    if (Object.keys(selectedTraits).length === 0) {
      alert("Please select at least one trait.");
      return;
    }

    selectNFTsMatchingAllTraits(selectedTraits, quantity);
  };

  // Clear button
  const btnClear = document.createElement("button");
  btnClear.textContent = "Clear Selection";
  btnClear.className = "mt-4 px-4 py-2 bg-red-600 text-white rounded";
  btnClear.onclick = () => {
    selectedNFTs.clear();
    for (const card of document.querySelectorAll("#nftList > div")) {
      card.classList.remove("ring-4", "ring-blue-500", "bg-blue-50");
    }
    selectedNft.textContent = "Selected: 0";
    document.getElementById("selectedDisplay").innerHTML = "";
  };

  container.appendChild(btnSelect);
  container.appendChild(btnClear);
}

function toggleSelectAll() {
  const cards = document.querySelectorAll("#nftList > div");
  const isAllSelected = Array.from(cards).every((card) => {
    const key = card.dataset.contract + ":" + card.dataset.tokenId;
    return selectedNFTs.has(key);
  });

  if (isAllSelected) {
    for (const card of cards) {
      const key = card.dataset.contract + ":" + card.dataset.tokenId;
      selectedNFTs.delete(key);
      card.classList.remove("ring-4", "ring-blue-500", "bg-blue-50");
    }
  } else {
    for (const card of cards) {
      const key = card.dataset.contract + ":" + card.dataset.tokenId;
      selectedNFTs.add(key);
      card.classList.add("ring-4", "ring-blue-500", "bg-blue-50");
    }
  }

  selectedNft.textContent = "Selected: " + selectedNFTs.size;
}

sortBtn.onclick = () => {
  let showdiv = document.getElementById("traitDropdowns");
  selectedNFTs.clear();
  for (const card of document.querySelectorAll("#nftList > div")) {
    card.classList.remove("ring-4", "ring-blue-500", "bg-blue-50");
  }
  if (showdiv.classList.contains("hidden")) {
    showdiv.classList.remove("hidden");
    renderTraitTable();
  } else {
    showdiv.classList.add("hidden");
  }
  selectedNft.textContent = "Selected: " + selectedNFTs.size;
};

document.getElementById("sendBtn").onclick = async () => {
  const btn = document.getElementById("sendBtn");
  btn.disabled = true;
  btn.innerText = "Sending...";

  let totalGasUsed = ethers.BigNumber.from(0);
  let totalFeeWei = ethers.BigNumber.from(0);
  const recipient = document.getElementById("recipient").value;
  let isSucsec = false;
  try {
    if (!recipient) {
      alert("Please enter recipient address");
      return;
    }
    if (selectedNFTs.size === 0) {
      alert("Select at least 1 NFT");
      return;
    }

    const batchItems = [];

    for (const key of selectedNFTs) {
      const [nftAddress, tokenId] = key.split(":");
      const nftContract = new ethers.Contract(
        nftAddress,
        NFT_CONTRACTS_[0].abi,
        signer
      );
      const isApproved = await nftContract.isApprovedForAll(
        userAddress,
        BATCH_CONTRACT_ADDRESS
      );
      if (!isApproved) {
        const tx = await nftContract.setApprovalForAll(
          BATCH_CONTRACT_ADDRESS,
          true
        );
        const approveReceipt = await tx.wait();
        totalGasUsed = totalGasUsed.add(approveReceipt.gasUsed);
        totalFeeWei = totalFeeWei.add(
          approveReceipt.gasUsed.mul(approveReceipt.effectiveGasPrice)
        );
        alert(`‚úÖ Approval granted to Batch Contract`);
      }

      batchItems.push({
        nftAddress,
        to: recipient,
        tokenId,
        amount: 1,
        tokenType: 0,
      });
    }

    const batchContract = new ethers.Contract(
      BATCH_CONTRACT_ADDRESS,
      BATCH_ABI,
      signer
    );
    const tx = await batchContract.batchTransfer(batchItems);
    const receipt = await tx.wait();

    totalGasUsed = totalGasUsed.add(receipt.gasUsed);
    totalFeeWei = totalFeeWei.add(
      receipt.gasUsed.mul(receipt.effectiveGasPrice)
    );

    const formattedFee = ethers.utils.formatEther(totalFeeWei);
    if (currency.usdPrice) {
      const feeInUSD = (Number(formattedFee) * currency.usdPrice).toFixed(4);
      alert(
        `‚úÖ Transaction complete\n\n‚Ä¢ Total Gas Used: ${totalGasUsed.toString()}\n‚Ä¢ Estimated Fee: $${feeInUSD} USD`
      );
    } else {
      alert(
        `‚úÖ Transaction complete\n\n‚Ä¢ Total Gas Used: ${totalGasUsed.toString()}\n‚Ä¢ Estimated Fee: ${formattedFee} ${
          currency.symbol
        }`
      );
    }

    btn.innerText = "‚úÖ Sent!";
    isSucsec = true;
  } catch (err) {
    console.error(err);
    alert("‚ùå Error: " + (err.message || "Unknown error"));
    btn.innerText = "üöÄ Send NFT";
  } finally {
    try {
      if (isSucsec) loadNFTs(NFT_CONTRACT);
    } catch (e) {
      console.warn("Failed to reload NFTs:", e);
    }
    isSucsec = false;
    btn.disabled = false;
    btn.innerText = "üöÄ Send NFT";
  }
};
